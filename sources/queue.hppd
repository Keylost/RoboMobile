#pragma once
#include <list>
#include <opencv2/opencv.hpp>
#include <pthread.h>

using namespace std;
using namespace cv;

class Object
{
	public:
	Mat *img;
	int useCount;
	
	Object()
	{
		img = new Mat();
		useCount = 0;
	}
	~Object()
	{
		img->release();
	}
};

struct Query
{
	Mat *img;
	Rect *roi;
	pthread_cond_t *cond;
};

/*
struct Query
{
	Object *obj;
	pthread_cond_t *cond;
};
*/

class Queue
{
	pthread_mutex_t _lock;	
	list<Query*> queries;	
	
	public:
	
	Queue()
	{
		_lock = PTHREAD_MUTEX_INITIALIZER;
	}
	
	void push(Query* obj)
	{
		pthread_mutex_lock(&(_lock));
		queries.push_back(obj);
		pthread_mutex_unlock(&(_lock));
		return;
	}
	
	void pop(list<Query*> &emptylist)
	{
		pthread_mutex_lock(&(_lock));
		queries.swap(emptylist);
		pthread_mutex_unlock(&(_lock));
		return;
	}
};

/*
 * Функция блокирует выполнение потока до тех пор пока в очереди не появится
 * новый элемент отличающийся от @curObj. После чего функция вернет управление 
 * изменив адрес curObj на адрес нового объекта
 */
/*
void waitForNewObject(Object *curObj)
{
	Object *oldobj = curObj;
	while(1)
	{
		pop(obj);
		if(curObj==NULL || oldobj==curObj)
		{
			usleep(1000); //1 ms
		}
		else break;
	}
	return;
}
*/
