
template<typename T>
void *garbage_collector_fnc(void *ptr)
{
	pthread_mutex_t &mutex_garbage = ((Queue<T> *)ptr)->mutex_garbage;
	vector<Object<T> *> &garbage = ((Queue<T> *)ptr)->garbage;
	
	while(1)
	{
		sleep(1);
		pthread_mutex_lock(&(mutex_garbage));
		vector<Object<T> *> gcopy(garbage);
		pthread_mutex_unlock(&(mutex_garbage));

		int sz = gcopy.size();
		printf("FPS: %d \n",sz);
		for(int i=0;i<sz;i++)
		{
			if(gcopy[i]->useCount==0)
			{
				delete gcopy[i];
				gcopy.erase(gcopy.begin()+i);
				sz--;
			}
		}
	
		pthread_mutex_lock(&(mutex_garbage));
		gcopy.swap(garbage);
		pthread_mutex_unlock(&(mutex_garbage));
	}
}

template<typename T>
void Queue<T>::add_to_garbage(Object<T> *eobj)
{
	pthread_mutex_lock(&(mutex_garbage));
	garbage.push_back(eobj);
	pthread_mutex_unlock(&(mutex_garbage));
}
	
template<typename T>
Queue<T>::Queue()
{
	_obj = NULL;
	mutex_garbage = PTHREAD_MUTEX_INITIALIZER;
	_lock = PTHREAD_MUTEX_INITIALIZER;
	pthread_t garbage_collector;
	pthread_create(&garbage_collector, NULL, garbage_collector_fnc<T>, this);
}

template<typename T>
void Queue<T>::push(Object<T> *obj)
{
	obj->useCount=1; //очередь получает объект раньше всех потоков
	pthread_mutex_lock(&(_lock));
	if(_obj!=NULL) _obj->free();
	_obj = obj;
	pthread_mutex_unlock(&(_lock));
	add_to_garbage(obj);
	return;
}

template<typename T>
Object<T> *Queue<T>::waitForNewObject(Object<T> *curObj)
{
	Object<T> *oldobj = curObj;
	while(1)
	{
		pthread_mutex_lock(&(_lock));
		curObj = _obj;
		pthread_mutex_unlock(&(_lock));
		if(curObj==NULL || oldobj==curObj)
		{
			usleep(1000); //1 ms
		}
		else
		{
			curObj->busy();
			break;
		}
	}
	return curObj;
}

template<typename T>
Object<T>::Object()
{
	useLock = PTHREAD_MUTEX_INITIALIZER;
	obj = new T();
	useCount = 0;
}

template<typename T>
Object<T>::~Object()
{
	delete obj;
}

template<typename T>
void Object<T>::free()
{
	pthread_mutex_lock(&(useLock));
	useCount--;
	pthread_mutex_unlock(&(useLock));
}

template<typename T>
void Object<T>::busy()
{
	pthread_mutex_lock(&(useLock));
	useCount++;
	pthread_mutex_unlock(&(useLock));
}
