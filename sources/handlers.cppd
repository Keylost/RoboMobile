#define ANGLE_CENTER  90 //угол сервомотора, при котором колеса робота смотрят прямо
#define ANGLE_RANGE  35 //максимальное отклонение сервомотора от центрального положения
#define MAX_SPEED  990 //максимальная скорость движения в условных единицах (от 0 до 999)
#define MIN_SPEED  450 //минимальная скорость движения в условных единицах (от 0 до 999)
#define ANGLE_MIN  (ANGLE_CENTER - ANGLE_RANGE)
#define ANGLE_MAX  (ANGLE_CENTER + ANGLE_RANGE)
uint32_t speed_crosswalk = MIN_SPEED; //скорость при обнаружении пешеходного перехода
uint32_t speed_stop      = 0; //скорость при обнаружении знака стоп
uint32_t speed_trafficlight  = 0; //скорость при обнаружении желтого или красного сигнала светофора

/*
 * Функция get_light2() определяет активный сигнал светофора
 * Входные данные:
 * Mat& roi - указатель на изображение светофора
 * Возвращаемые значения:
 * 0 - зеленый
 * 1 - красный
 * 2 - желтый
 */
uint8_t get_light2(Mat& roi)
{
	int rg=0,rb=0,gb=0;
	int b=0,g=0,r=0;
	
	uint8_t *row;
	for(int rows=0;rows<roi.rows;rows++)
	{
		row = (uint8_t*)roi.ptr<uint8_t>(rows);
		for(int col=0;col<roi.cols;col++)
		{
			b = row[col*3]; g=row[col*3+1]; r=row[col*3+2];
			if(r-g>rg) rg=r-g;
			if(r-b>rb) rb=r-b;
			if(g-b>gb) gb=g-b;
		}
	}
	
	if(rb>150 && rg>150 && gb<120 ) return 1;
	if(gb>100 && rb>100) return 2;
	else return 0;
}

/*
 * Функция handle_sign() занимается обработкой информации о найденных знаках
 * Входные данные:
 * Mat& orig - указатель на текущее обрабатываемое цветное(BGR) изображение, полученное с камеры.
 * 
 * В зависимости от информации о знаке, содержащийся в поле mysign объекта класса Recognition, управляет поведением робота.
 * Например, устанавливает таймер, определяющий время, на которое робот должен сбросить скорость при найденнном знаке "пешеходный переход"
 * или время, в течении которого робот будет стоять у знака "стоп".
 */
bool red_catch = false;
bool sign_catch = false;
Mat templ;
void Recognition::handle_sign(const Mat& orig)
{
	switch(mysign.sign)
	{
	case sign_none:
	{
		break;
	}
	case sign_stop:
	{
		if(timer==0) 
		{
			time(&timer);
		}
		else
		{
			time_t diff = time(NULL)-timer;
			if(diff<=0) 
			{
				break;
			}
			else if(diff<=3)
			{
				engine.speed = speed_stop;
			}
			else if(diff<=5)
			{
				break;
			}
			else 
			{
				timer=0;
				mysign.sign = sign_none;
			}
		}
		break;
	}
	case sign_giveway:
	{
		if(!sign_catch)
		{			
			Mat vr = orig(Rect(Point(orig.cols/2 + mysign.area.x,mysign.area.y),Point(orig.cols/2 + mysign.area.x+mysign.area.width,mysign.area.y+mysign.area.height)));
			sign_catch = true;
			cvtColor(vr,templ,CV_BGR2GRAY);
			break;
		}
		Mat roi = orig(Rect(Point(orig.cols/2,0), Point(orig.cols-1,orig.rows/2)));
		cvtColor(roi,roi,CV_BGR2GRAY);
		double maxval = 0;
		Point matchLoc = TplMatch(roi, templ,maxval);
		if(maxval<0.6)
		{
			sign_catch = false;
			mysign.sign = sign_none;
			break;
		}
		mysign.area = Rect(matchLoc, Point(matchLoc.x + templ.cols , matchLoc.y + templ.rows ));
		Mat vr = orig(Rect(Point(orig.cols/2 + mysign.area.x,mysign.area.y),Point(orig.cols/2 + mysign.area.x+mysign.area.width,mysign.area.y+mysign.area.height)));
		cvtColor(vr,templ,CV_BGR2GRAY);
		break;
	}
	case sign_mainroad:
	{
		if(!sign_catch)
		{			
			Mat vr = orig(Rect(Point(orig.cols/2 + mysign.area.x,mysign.area.y),Point(orig.cols/2 + mysign.area.x+mysign.area.width,mysign.area.y+mysign.area.height)));
			sign_catch = true;
			cvtColor(vr,templ,CV_BGR2GRAY);
			break;
		}
		Mat roi = orig(Rect(Point(orig.cols/2,0), Point(orig.cols-1,orig.rows/2)));
		cvtColor(roi,roi,CV_BGR2GRAY);
		double maxval = 0;
		Point matchLoc = TplMatch(roi, templ,maxval);
		if(maxval<0.6)
		{
			sign_catch = false;
			mysign.sign = sign_none;
			break;
		}
		mysign.area = Rect(matchLoc, Point(matchLoc.x + templ.cols , matchLoc.y + templ.rows ));
		Mat vr = orig(Rect(Point(orig.cols/2 + mysign.area.x,mysign.area.y),Point(orig.cols/2 + mysign.area.x+mysign.area.width,mysign.area.y+mysign.area.height)));
		cvtColor(vr,templ,CV_BGR2GRAY);
		break;
	}
	case sign_crosswalk:
	{		
		if(timer==0) 
		{
			time(&timer);
		}
		else
		{
			time_t diff = time(NULL)-timer;
			if(diff<=1) 
			{		
				break;
			}
			else if(diff<=4)
			{
				engine.speed = speed_crosswalk;
			}
			else 
			{
				timer=0;
				mysign.sign = sign_none;
			}
		
		}
		break;
	}
	case sign_trafficlight:
	{
		int k =0;
		Mat roi   = orig(Rect(Point(orig.cols/2 + mysign.area.x-k,mysign.area.y-k),Point(orig.cols/2 + mysign.area.x+mysign.area.width+k,mysign.area.y+mysign.area.height+k)));
		uint32_t light = get_light2(roi);
		
		switch(light)
		{
		case 0:
		{
			LOG("[I]: Green light found");
			mysign.state = greenlight;
			mysign.sign = sign_none;
			break;
		}		
		case 1:
		{
			LOG("[I]: Red light found");
			mysign.state = redlight;
			engine.speed = speed_trafficlight;
			break;
		}
		case 2:
		{
			LOG("[I]: Yellow light found");
			mysign.state = yellowlight;
			engine.speed = speed_trafficlight;
			break;
		}
		case 3:
		{
			LOG("[I]: Tracking error?");
			mysign.state = greenlight;
			mysign.sign = sign_none;
			break;
		}
		}
		if(myline.stop_line && mysign.state!=greenlight)
		{
			if(timer_line.get()>700) mysign.sign = sign_none;
			else if(timer_line.get()>0)
			{
				timer_line.start();
			}
		}
		
		
		break;
	}
	}
}
